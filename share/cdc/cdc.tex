\documentclass[a4paper]{report}

\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[official]{eurosym}
\usepackage{epigraph}


\usepackage{courier}

%%PACKAGE MAX
\usepackage{fancybox}
\usepackage{tikz}
\usepackage{color}
\usepackage{listings}
\usepackage{wrapfig}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{
  backgroundcolor=\color{white},
  basicstyle=\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{mygreen},
  deletekeywords={...},
  escapeinside={\%*}{*)},
  extendedchars=true,
  frame=single,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=Octave,
  morekeywords={*,...},
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{mygray},
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=1,
  stringstyle=\color{mymauve},
  tabsize=2,
  title=\lstname
}

\lstdefinestyle{base}{
  language=C,
  emptylines=1,
  breaklines=true,
  basicstyle=\ttfamily\color{black},
  moredelim=**[is][\color{mygreen}]{@}{@},
  moredelim=**[is][\color{blue}]{µ}{µ},
    moredelim=**[is][\color{blue}]{~}{~},
}

\include{pageGarde}

\tableofcontents

% Lucien
\chapter*{Introduction}

A2C est un projet informatique réalisé dans le cadre de la seconde année des
classes préparatoires de l’EPITA, école d’ingénieur en informatique. Le projet
s'étale sur 4 mois et le sujet est libre. C’est pourquoi nous avons décidé de
nous lancer dans la réalisation d’un compilateur du langage algo (langage
‘théorique’ proche du pascal, utilisé à but pédagogique à EPITA) vers le
langage C.


% Maxime, Arys
\chapter{Présentation du projet}
Le but de ce projet est d'écrire un compilateur à partir de zero. Il compilera
le langage algorithmique, enseigné en classe préparatoire de l'EPITA, vers du
C.

Autrement dit, nous n'allons implémenter que la partie ``front-end'' du
compilateur : analyse lexicale, syntaxique et sémantique. La partie
``back-end''
sera gérée par un compilateur C tel que gcc ou clang.\\

Ce choix est dû au fait que l'écriture complète d'un compilateur nous semble
trop ambitieux, et que la partie ``front-end'' est celle qui nous paraissait la
plus intéressante d'un point de vue algorithmique.\\

Le public cible de ce compilateur sont les sups et les spés utilisant le
langage algo en cours et en travaux pratiques. Il peut également servir à toute
autre personne, car il sera libre et open source.

\include{algo}

\chapter{Présentation du groupe}
\section{Présentation de l'équipe}
\input{presLucien}
\include{presMax}
\subsection{Charles ``Arys'' Yaiche}
Un bel homme originaire à la fois de la Tunisie, de la Pologne, de l'Italie et
du Pays basque, Arys (de son nom d'origine Charles mais comme c'était pas assez
swag Arys c'est mieux, et puis c'est un peu une marque de pain brioché, et ça
c'est la classe) est né dans la ville rose, j'ai nommé, Toulouse... on ne peut
pas être parfait.  Ce valeureux personnage a très rapidement fui Toulouse
avant même de savoir parler (pour ne pas choper l'accent) pour aller se réfugier
dans la capitale, c'est dans cette même capitale qu'il fera une partie de sa
vie.  Notre personnage agé maintenant de 16 ans décide de quitter la maison et de
partir à l'aventure à l'autre bout du monde, j'ai appellé Chicago pendant deux
ans, deux ans plus tard, il passe avec succès le Baccalauréat mention "raz des
fesses" et est accepté dans "la meilleure école d'ingénieur en informatique de
France" citation du directeur. Il valide sa première année, il va... redoubler
sa seconde année lors de son départ en Chine parce que un chinois l'avait entubé
lui et ses camarades, mais il faut savoir que tout est de notre faute car de
toute façon tout est toujours notre faute et il parait que on a rien foutu aussi
d'après la direction qui est en contact permanant avec l'université de Chine.
C'est donc lors de ce quatrième semestre avec une promotion inconnue que notre
héro doit s'intégrer pour former un groupe de projet libre, je trouve que il
s'est très bien intégré sachant que l'ensemble des membres du groupes sont tous
redoublant.

\subsection{Thibaud ``Zehir'' Michaud}
C'est avec les calculatrices scientifiques utilisées au lycée que j'ai commencé
à m'intéresser à la programmation. Alliant à la fois la logique implacable des
mathématiques et le côté pratique de la physique, l'informatique était pour moi
la science qui manquait dans l'enseignement. C'est alors que j'ai découvert, ô
joie, que certaines écoles étaient (presque) entièrement dédiées à ce domaine.
L'EPITA en faisait partie et proposait en plus une pédagogie par projet
particulièrement attrayante.

Je suis de nature ambitieuse, et ça m'a d'ailleurs coûté un semestre. Parti pour
un semestre d'étude à Tampere (Finlande), destination réputée difficile, j'ai
voulu prendre des cours qui semblaient intéressants mais pour lesquels il s'est
avéré que je n'avais pas le niveau.

Me voilà donc avec un semestre de libre (puisque déjà validé l'année précédente)
durant lequel je fais un stage au Laboratoire de Recherche et de Développement
de l'EPITA (LRDE). Durant ce semestre je dois trouver un sujet et un groupe de
projet pour le semestre suivant.

Pour ce projet de 4ème semestre, je voulais quelque chose d'ambitieux mais pas
trop. La suggestion de Maxime, faire un kernel, me paraissait pour le coup un
peu trop ambitieuse. Mais on a fini par tous se mettre d'accord sur la
réalisation d'un compilateur.

\section{Philosophie du groupe}
En tant qu'étudiants en infornatique, les nouvelles technologies nous
passionnent, très rapidement immergés dans le monde Unix, nous sommes militants
pour le logiciel libre (à l'exception de Lucien qui utilise un Mac). 
Fervents utilisateurs de vim (sauf Lucien qui utilise emacs) ergonomie est notre
mot d'ordre avec deux membres utilisant des claviers ergonomique bépo et
dvorak.\\

Partant du principe que nous sommes là pour apprendre, nous avons décidé de tout
implémenter nous même : structures de données, parseur, etc. (à l'exception du
back-end parce que faut pas exagérer quand même).

\chapter{Découpage du projet}
Les premiers compilateurs ne faisaient qu'une seule passe. C'est à dire qu'ils
généraient le code machine au fur et à mesure qu'ils parcouraient le code
source. Cette approche à plusieurs avantages mais a surtout un gros désavantage
: elle n'est pas modulaire et est difficile à maintenir.

Les compilateurs modernes préfèrent donc effectuer plusieurs passes : analyse
lexicale, analyse syntaxique, analyse sémantique et génération de code machine.
Certaines de ces étapes peuvent encore être subdivisées, mais c'est ce découpage
global que nous allons suivre pour notre projet, et que nous allons détailler
dans cette partie.

Mais avant de se lancer dans la programmation du compilateur, il est important
que nous ayons une implémantation fiable et facile d'utilisation de quelques
structures de données de base.

% Lucien, Thibaud
\newpage
\section{Structures de données}
\epigraph{Bad programmers worry about the code. Good programmers worry about
data structures and their relationships.}{Linus Torvalds}
La plupart des langages de programmation haut niveau fournissent des structures
de données génériques dans leur bibliothèque standard, car les structures de
données sont au cœur de la programmation. Mais notre projet doit être fait en C,
et en C la bibliothèque standard ne contient pas de structures de données.\\

Il semblerait qu'il existe des bibliothèques non standard implémentant des
structures de données génériques, telle que klib, mais on préfère tout
réimplémenter nous même, c'est une bonne occasion de mettre en pratique tout ce
qu'on a vu en algo. [cf. philosophie du groupe]\\

Un gros obstacle sera la généricité. Les différentes étapes de la compilation
vont utiliser les mêmes structures de données, mais avec des données de types
différents. Et le C étant relativement bas niveau, rien ne permet d'avoir
nativement des types génériques.\\

Pour palier à ce probléme plusieurs solutions existent parmis lesquelles :\\
\begin{itemize}
    \item Implémenter les structures sous forme de macros. Les macros prennent
      en paramètre le type utilisé et seront remplacées à la compilation par le
      code implémentant les structures de données avec le bon type. C'est un peu
      le même principe que les templates C++ en plus basique. C'est aussi la
      solution adoptée par la bibliothèque klib
      (https://github.com/attractivechaos/klib).
    \item Utiliser des types \texttt{void *} dans toutes les structures, et
      caster en fonction du type utilisé. Cette solution est probablement la
      plus simple, mais on perd tout l'intérêt de l'analyse de type statique.
    \item Utiliser des structures de données intrusives : le principe est
      d'inclure la structure de données dans les données plutôt que
      l'inverse. C'est notamment la solution adoptée par le noyau Linux.\\
\end{itemize}

Chacune de ces méthodes à des avantages et des inconvénients. Mais la dernière
solution semble être celle qui offre le meilleur compromis, et c'est
probablement celle que nous allons choisir.\\

Une fois les structures de base implémentées (listes chainées, tables de
hachage, etc.) nous allons pouvoir attaquer l'implémentation de la toute
première étape de la compilation : l'analyse lexicale.
\newpage
% Lucien, Thibaud
\section{Analyse lexicale}
L'analyse lexicale consiste à découper le code source en entités lexicales, ou
lexèmes (``token'' en anglais), c'est à dire transformer le code source en un
flux de mots-clés, d'opérateurs, d'identifiants, de valeurs numériques, \ldots\\

\section{Analyse syntaxique}
L'analyse syntaxique consiste à trouver la structure grammaticale du
code source à partir du flux de tokens renvoyé par l'analyseur lexical. Dans
tous les compilateurs modernes, cette structure est exprimée sous la forme d'un
arbre dit ``Arbre syntaxique abstrait'', ou AST.

% Lucien
\subsection{Construction de la grammaire}
\subsubsection{Qu’est-ce qu’une grammaire ?}
Dans les langages naturels, une grammaire construit les phrases, elle ne
s’intéresse pas au sens, mais à la syntaxe. Dans les langages informatique,
cette grammaire agit pareil, elle va participer à la correction syntaxique, et
non au sens des expressions formées. Ainsi une phrase comme “Elle mange une
voiture” est syntaxiquement correcte, tout comme “int positive = -1; “ l’est.


Une grammaire formelle (ou, simplement, grammaire) est constituée des quatre
objets suivants:
\begin{itemize}
  \item Un ensemble fini de symboles, appelés symboles terminaux (qui sont
les « lettres » du langage), notés conventionnellement par des minuscules.
\item Un ensemble fini de symboles, appelés non-terminaux, notés
conventionnellement par des majuscules.
\item Un élément de l'ensemble des non-terminaux, appelé axiome, noté
conventionnellement S.
\item Un ensemble de règles de production, qui sont des paires formées
d'un non-terminal et d'une suite de terminaux et de non-terminaux.
\end{itemize}
Ainsi une grammaire peut être caricaturée comme un ensemble de règles auquel
obéissent des variables, le but étant de caractériser le langage.

\subsubsection{Quel type de grammaire?}
Il existe plusieurs types de grammaires (monotones, sensibles au contexte,
rationnelles … etc) définis par la hierarchie de Chomsky. Il s’agira de choisir
une grammaire conformément à notre langage, ainsi l’idée d’une grammaire finie
ou rationnelle est tout bonnement proscrite.

En effet la construction d’un langage informatique, ne peut se faire via quelque
chose de rationnel. L’une des raison à cela est le problème soulevé par anbn,
qui peut représenter le matching de toutes les parenthèses, que la rationnalité
ne peut détecter.

Il reste donc à voir si une grammaire Hors Contexte (CF pour context free en
anglais) peut suffire, ou si on doit extrapoler à une grammaire sensible au
contexte. La réponse est oui, la principale barrière induite par la rationnalité
étant détruite, le Hors Contexte suffit à la réalisation de la plupart des
langages informatique, dont le notre.

Definition:
Une grammaire hors contexte est tout simplement une grammaire formelle dans
laquelle chaque règle de production (ou simplement production) est de la forme
X -> w
où X est un symbole non terminal et w est une chaîne composée de terminaux et/ou
de non-terminaux.

\subsubsection{Realisation}
La construction de la grammaire peut être separé en deux étapes majeures. La
première étant de construire la grammaire qui définie notre langage, sans
s’occuper des quelconques problèmes ( cette grammaire est souvent appelée
grammaire abstraite). La seconde étant la résolution de cette grammaire, c’est à
dire résoudre les divers conflits et ambiguités (souvent appelée grammaire
concrête). Une ambiguité est tout simplement deux chemins possibles.
Il est également possible de créer un automate à partir de la grammaire, ce qui
peut grandement simplifier la réalisation du parseur.

% Thibaud
\subsection{Ecriture de l'analyseur syntaxique}
La construction d'un parseur sera une partie assez longue et fastidieuse.
Cependant elle sera grandement facilité par l'étape précédente, à savoir la
construction de la grammaire.
Il existe deux grandes familles de parsing : LR(1) et LL(1). Le chiffre
correspong au nombre de 'look ahead' (symbole de surete pour regarder en avant
dans le parsing). La différence entre LR et LL provient de la dérivation sur
laquelle on travaille: gauche (left) pour LL et droite (right) pour LR.

Plusieurs choix s'offrent donc à nous, il s'agira ici de choisir entre
performance et faisabilité. Si la grammaire est LL, il sera alors beaucoup plus
simple d'implémenter un parseur LL. Si au contraire la grammaire est LR, il
faudra se lancer dans un parseur LR, plus compliqué mais très efficace et auquel
pour se rajouter des amélioration comme LR(0), LALR(1) ou SLR(1).

% Maxime
\include{semantique}

% Arys
\section{Génération de code C et compilation du code généré}
L'arbre syntaxique précédament construit permettera ensuite de générer du code 
une fois le compilateur ayant générer le code C, celui-ci sera compiler en par n'importe quel compilateur du langage C comme gcc, ou alors clang

% Lucien
\section{Site web}
Comme dans tout projet informatique, la construction d’un site web, et
l’écriture d’articles tout le long de la réalisation du projet, est quelque
chose d’indispensable à sa communication. En dehors du fait de laisser notre
trace sur internet, le site web peut apparaitre comme un portail de communication
entre les developpeurs (nous) et les utilisateurs, ou encore avec d’autres
développeurs voulant connaitre un peu plus en détail notre compilateur et pourquoi
pas nous contacter.
De plus le site web permet un téléchargement simple du compilateur et centralise
toutes les ressources nécéssaires (github, page FB, liens vers des articles en
rapport .. etc).

Le site sera également un élément essentiel dans la réalisation éventuelle d’un
de nos bonus, car il hébergera potentiellement le compilateur interactif.

Les technologies utilisées seront HTML/CSS, et Javascript si l’on parvient à
mettre en place le bonus.

% Maxime
\include{chrono}

% Arys
\chapter{Bonus}
Dans le cas ou le compilateur serait fini en avance, l'équipe a fait une
sélection de bonus.
\begin{itemize}
  \item Optimisation du code généré
  \item Gestion de plusieurs fichiers pour la compilation
  \item Implémentation de bibliothèques pour le langage algo, comme par exemple implémentation des différentes structures de données
  \item Gestion Français/Anglais pour les classes internationales
  \item Un compilateur web interactif, ou les élèves pourront compiler leur code en ligne
  \item Un IDE pour le langage algo
  \item Un plugin de syntaxe Vim
\end{itemize}
Bref nous ne sommes pas en panne d'imagination pour toute sorte d'améliorations
diverses et variées


% Maxime
\include{tech}

% Maxime
\include{cout}

% Lucien
\chapter*{Conclusion}
Nous avons conscience de la charge de travail qu’il faudra fournir au vue de nos
compétences peu avancées dans le domaines, puisqu’il nous manque une grosse
partie de la base théorique enseignée en ING1. Mais sont sommes extrémement
motivés et confiant quant à la réalisation de ce projet, et espérons y prendre
du plaisir.

%Arys
\chapter*{Sources}
Nos sources:
\begin{itemize}
  \item Le projet Tiger Compiler d'ÉPITA (https://www.lrde.epita.fr/akim/ccmp/assignments.html)
  \item Modern compiler implementation in ML
  \item Compiler: Principles, Techinques, and Tools (Dragon Book)
  \item http://llvm.org/docs/tutorial
  \item http://www.stack.nl/marcov/compiler.pdf
\end{itemize}

\chapter*{Annexes}

\end{document}
